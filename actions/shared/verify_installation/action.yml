name: 'Verify Installation Action'
description: 'A GitHub Action to verify Kubernetes deployments including status checks, log collection, and test validation.'
inputs:
  namespace:
    description: |
      Kubernetes namespace for service installation
    required: true

  service_ready_max_retries:
    description: |
      Maximum retries for provisioner pod or custom resource to be completed
    required: true

  service_ready_retry_interval:
    description: |
      Delay between provisioner pod / CR check attempts (in seconds)
    required: true

  test_completion_max_retries:
    description: |
      Maximum verification retries for test pod to be completed
    required: true

  test_completion_retry_interval:
    description: |
      Delay between test pod check attempts
    required: true

  service_branch:
    description: |
      Branch in service repository
    required: false

  crd_list:
    description: |
      List of custom resource definitions for checking deploy status.
    required: false

  check_tests:
    description: |
      Enable test checks (true) or disable them (false)
    required: false
    type: boolean
    default: true

  artifact_name:
    description: |
      Name of the artifact to be uploaded
    required: false
    default: ""

  monitoring_tests:
      description: |
        Enable monitoring CRs checks (true) or disable them (false)
      required: false
      type: boolean
      default: false

runs:
  using: "composite"
  steps:
    - name: Create folder for artifacts
      shell: bash
      # language=bash
      run: mkdir -p artifacts

    - name: Initialize error flag
      shell: bash
      # language=bash
      run: echo "ERROR_FLAG=false" >> $GITHUB_ENV

    - name: Check service is ready
      shell: bash
      # language=bash
      run: |
        # ▶️ Check service is ready
        chmod +x ./qubership-test-pipelines/scripts/check_cr.sh
        chmod +x ./qubership-test-pipelines/scripts/check_resources.sh

        echo "Checking CRDs: ${{inputs.crd_list}}"
        cr_success=false
        resources_success=false

        for i in {1..${{inputs.service_ready_max_retries}}}; do
          echo "Attempt $i/${{inputs.service_ready_max_retries}}"

          if [ "$cr_success" = "false" ]; then
            set +e
            ./qubership-test-pipelines/scripts/check_cr.sh "${{inputs.crd_list}}" "${{inputs.namespace}}"
            cr_exit_code=$?
            set -e

            case $cr_exit_code in
              0)
                echo "✅ CR check successful"
                cr_success=true
                break
                ;;
              1)
                echo "⏳ CR check in progress"
                echo -e "Retrying in ${{inputs.service_ready_retry_interval}} seconds...\n"
                sleep ${{inputs.service_ready_retry_interval}}
                ;;
              2)
                echo "::error:: ❌ CR check failed"
                echo "ERROR_FLAG=true" >> $GITHUB_ENV
                break
                ;;
            esac
          fi
          done
          if [[ "${{ inputs.monitoring_tests }}" == "true" ]]; then
                # ▶️ Check monitoring CRs statuses
                echo "Checking VictoriaMetrics CRs in namespace: ${{inputs.namespace}}"
                chmod +x ./qubership-test-pipelines/scripts/check-vm-cr-statuses.sh
                ./qubership-test-pipelines/scripts/check-vm-cr-statuses.sh ${{inputs.namespace}} ${{inputs.service_ready_max_retries}} ${{inputs.service_ready_retry_interval}} ./qubership-test-pipelines/actions/monitoring/expected-vm-cr-statuses.json
          fi
          for i in {1..${{inputs.service_ready_max_retries}}}; do
            echo "Attempt $i/${{inputs.service_ready_max_retries}}"
            if [ "$resources_success" = "false" ]; then
              set +e
              ./qubership-test-pipelines/scripts/check_resources.sh "${{inputs.namespace}}"
              resources_exit_code=$?
              set -e
  
              if [ $resources_exit_code -eq 0 ]; then
                echo "✅ Resources checks successful"
                resources_success=true
                break
              elif [ $resources_exit_code -eq 1 ]; then
                echo "⏳ Some resources are not ready"
                echo "PODS:"
                kubectl get pods -n "${{inputs.namespace}}"
              fi
            fi
          done

          if [ "$cr_success" = "true" ] && [ "$resources_success" = "true" ]; then
            echo "✅ All checks completed successfully!"
            exit 0
          fi
          if [ "$cr_success" = "false" ]; then
            echo "::error:: ❌ CR check not successful after ${{inputs.service_ready_max_retries}} retries"
            echo "ERROR_FLAG=true" >> $GITHUB_ENV
            exit 1
          fi
          if [ "$resources_success" = "false" ]; then
            echo "::error:: ❌ Resources not ready after ${{inputs.service_ready_max_retries}} retries"
            echo "ERROR_FLAG=true" >> $GITHUB_ENV
            exit 1
          fi

    - name: Get logs from test pod
      if: ${{ inputs.check_tests == 'true' }}
      shell: bash
      # language=bash
      run: |
        # ▶️ Set TIMEOUT-BEFORE-START and restart tests pod
        if [[ "${{inputs.monitoring_tests}}" == "true" ]]; then        
        # debug info
        echo "etcd pod IP: $(kubectl get pods -n kube-system -l component=etcd -o jsonpath='{.items[*].status.podIP})'"
        echo "Saving vmagent targets to artifacts/targets.json"
        kubectl exec -n monitoring $(kubectl get pods -l name=grafana -n monitoring -o jsonpath='{.items[0].metadata.name}')  -- curl -s 'http://vmagent-k8s:8429/api/v1/targets?job=etcd' > artifacts/targets.json
        echo "etcd client cert:"
        kubectl get secret kube-etcd-client-certs -n monitoring -o jsonpath='{.data.etcd-client\.crt}' | base64 -d | openssl x509 -text -noout
        echo "Patching tests deployment to set TIMEOUT-BEFORE-START to 20 seconds and restart pod"
        kubectl set env deployment/monitoring-tests -n "${{inputs.namespace}}" TIMEOUT-BEFORE-START="20"
        echo "Waiting 20 seconds before checking test results..."
        sleep 20
        fi
        # ▶️ Get logs from test pod
        chmod +x ./qubership-test-pipelines/scripts/check_tests.sh
        ls -la ./qubership-test-pipelines/scripts/check_tests.sh

        for i in $(seq 1 ${{inputs.test_completion_max_retries}}); do
          echo "Test check attempt $i/${{inputs.test_completion_max_retries}}"
          set +e
          ./qubership-test-pipelines/scripts/check_tests.sh "${{inputs.namespace}}"
          tests_exit_code=$?
          set -e

          case $tests_exit_code in
            0)
              echo "✅ Tests passed successfully"
              break
              ;;
            1)
              echo "⏳ Tests still in progress"
              ;;
            2)
              echo "::error:: ❌ Tests failed"
              echo "ERROR_FLAG=true" >> $GITHUB_ENV
              break
              ;;
          esac

          if [ $i -eq ${{inputs.test_completion_max_retries}} ]; then
            echo "::warning:: ⚠️ Tests not completed after ${{inputs.test_completion_max_retries}} retries"
            echo "ERROR_FLAG=true" >> $GITHUB_ENV
          else
            sleep ${{inputs.service_ready_retry_interval}}
          fi
        done
    - name: Get pods
      shell: bash
      # language=bash
      if: always()
      run: |
        # ▶️ Get pods
        file_name="artifacts/${{inputs.namespace}}_get_pods.txt"
        kubectl get pods -n "${{inputs.namespace}}"
        kubectl get pods -n "${{inputs.namespace}}" > "$file_name"

    - name: Get yaml from pods
      shell: bash
      # language=bash
      if: always()
      run: |
        # ▶️ Get yaml from pods
        file_name="artifacts/${{inputs.namespace}}_get_pods_yaml.txt"
        IFS=" " read -ra pods <<< "$(kubectl get pods --no-headers -o custom-columns=":metadata.name" -n "${{inputs.namespace}}" | tr "\n" " ")"
        echo "Yaml files from pods:" > "$file_name"
        for pod in "${pods[@]}"; do
            echo "$pod" >> "$file_name"
            kubectl get pod "$pod" -n "${{inputs.namespace}}" -o yaml >> "$file_name"
        done

    - name: Get events from namespace
      shell: bash
      # language=bash
      if: always()
      run: |
        # ▶️ Get events from namespace
        file_name="artifacts/${{inputs.namespace}}_get_events.txt"
        kubectl events -n "${{inputs.namespace}}" > "$file_name"

    - name: Get yaml from PVC
      shell: bash
      # language=bash
      if: always()
      run: |
        # ▶️ Get yaml from PVC
        file_name="artifacts/${{inputs.namespace}}_get_pvc_yaml.txt"
        kubectl get pvc -n "${{inputs.namespace}}"
        kubectl get pvc -n "${{inputs.namespace}}" -o yaml > "$file_name"

    - name: Get PV from namespace
      shell: bash
      # language=bash
      if: always()
      run: |
        # ▶️ Get PV from namespace
        file_name="artifacts/${{inputs.namespace}}_get_pv.txt"
        if kubectl get pv 2>/dev/null | grep -q "${{inputs.namespace}}"; then
          kubectl get pv | grep "${{inputs.namespace}}" > "$file_name"
          echo "✅ PV found and saved to $file_name"
        else
          echo "No PV found for namespace ${{inputs.namespace}}" > "$file_name"
          echo "ℹ️ No PV found for namespace ${{inputs.namespace}}"
        fi

    - name: Get logs from all containers in pods
      shell: bash
      # language=bash
      if: always()
      run: |
        # ▶️ Get logs from all containers in pods
        file_name="artifacts/${{inputs.namespace}}_log_from_containers.txt"
        IFS=" " read -ra pods <<< "$(kubectl get pods --no-headers -o custom-columns=":metadata.name" -n "${{inputs.namespace}}" | tr "\n" " ")"
        echo "Logs from all containers in pods:" > "$file_name"
        for pod in "${pods[@]}"; do
            IFS=" " read -ra containers <<< "$(kubectl get pod "$pod" -n "${{inputs.namespace}}" -o jsonpath="{.spec.containers[*].name}")"
            for container in "${containers[@]}"; do
              echo "$pod $container" >> "$file_name"
              kubectl logs "$pod" -n "${{inputs.namespace}}" -c "$container" >> "$file_name"
              echo "================================================================================" >> "$file_name"
            done
        done

    - name: Get All
      shell: bash
      # language=bash
      if: always()
      run: kubectl get all -n "${{inputs.namespace}}"

    - name: Get Secrets
      shell: bash
      # language=bash
      if: always()
      run: kubectl get secrets -n "${{inputs.namespace}}"

    - name: Generate artifact name
      if: always()
      shell: bash
      # language=bash
      run: |
        # ▶️ Generate artifact name
        service_branch=$(echo "${{inputs.service_branch}}" | tr -d '[:space:]')
        if [[ -n "$release_name" ]]; then
          service_branch="_${service_branch//\//_}"
        fi
        echo matrix_version ${{matrix.version}}
        matrix_suffix=""
        if [[ -n "${{ matrix.version }}" ]]; then
          echo ${{ matrix.version }}
          matrix_suffix="${{matrix.version}}_"
        fi

        if [[ "${{inputs.artifact_name}}" != "" ]]; then
          ARTIFACT_NAME=${{ inputs.artifact_name }}_$(date -u +'%Y%m%d%H%M%S')
        else
          ARTIFACT_NAME="${{github.job}}_${{inputs.namespace}}${service_branch}_${matrix_suffix}artifacts_$(date -u +"%Y%m%d%H%M%S")"
        fi
        echo "ARTIFACT_NAME=$ARTIFACT_NAME" >> $GITHUB_ENV

    - name: Upload artifact
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: "${{env.ARTIFACT_NAME}}"
        path: artifacts/

    - name: Check job status
      shell: bash
      # language=bash
      run: |
        # ▶️ Check deploy status
        if [[ "${{ env.ERROR_FLAG }}" == "true" ]]; then
          echo "::error:: ❌ Service was installed with errors!"
          exit 1
        else
          echo "✅ Service installation completed successfully"
        fi
